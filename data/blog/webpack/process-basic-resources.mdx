---
title: webpack 的基本资源解析
date: '2023-03-20'
tags: ['webpack']
draft: false
summary: 介绍 webpack 中如何对基本的资源进行解析，比如 ES6+、React JSX、CSS、图片与字体等资源文件。
---

webpack 原生只支持 JS 和 JSON 两种文件类型，而对于其他类型的文件，诸如 jsx/tsx 等语法糖、css (包括 less, sass, stylus 等)、图片、字体等文件，webpack 并不知道它们是什么。

我们使用 loaders 处理其它文件类型，把它们转换成有效的模块，可以将文件从不同的语言，比如 TypeScript，转换为 JavaScript；或者将内联图像转换为 data URL 等。

# From Scratch

现在，我们从零开始为每种资源文件使用针对性的 loader 进行处理，来看看资源解析的细节。

我们新建了一个项目 process-resources，按照这里提供的[环境安装](/blog/webpack/init-project#环境安装)方式搭建好初始化环境，
但不需要通过 `webpack init` 快速初始化出 webpack 的配置文件，因为这里我们选择从零开始配置环境，从而建立对每种资源处理所需要的完整配置有个清晰的认识。

在项目根目录下创建一个 webpack 的配置文件 `webpack.config.js`。

```js
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js', // 默认是 main.js
  },
  mode: 'development',
  plugins: [
    new HtmlWebpackPlugin({
      template: 'index.html',
    }),
  ],
}
```

并在 package.json 文件的 `scripts` 中添加脚本，后续执行 `npm run start` 即可测试构建结果。

```json
{
  "scripts": {
    "start": "webpack"
  }
}
```

# 资源解析

webpack 中解析不同类型的资源主要用到 loader，它的配置层级是在 module.rules 数组中。

每一条Rule规则的常用属性如下，其中 + 表示 webpack 5 更新的部分。

```diff
  test: 匹配资源文件的正则表达式，上面的代码是匹配 png 图片
- type: 设置资源模块类型 （支持 'javascript/auto' | 'javascript/dynamic' | 'javascript/esm' | 'json' | 'webassembly/experimental'）
+ type: 设置资源模块类型 （新增 asset 与 asset/* 资源模块类型）
  use/loader: 设置加载器，类型可以是 String | Object | Array
+ generator: 设置资源生成信息
+   - filename: 设置资源文件输出名称和保存的路径（只适用于 type 属性为 asset 和 asset/resource 的场景）
  include: 手动添加必须处理的文件（文件夹）
  exclude: 手动屏蔽不需要处理的文件（文件夹）
```

## ES6+

我们在前端项目中使用的一般是 ES6+ 语法，而在浏览器中不一定能够支持这些语法特性，比如 Class, Promise 等，可以通过 [caniuse](https://caniuse.com) 查看语法特性的兼容性。

webpack 原生支持 JS 的解析，但对于 ES6+ 的语法特性需要降级，输出为 ES5 的代码。而降级需要依赖到 babel-loader。

babel-loader 是依赖 babel 的，所以需要安装 babel 与 babel-loader，并且需要为 babel 添加配置文件，其配置文件是 .babelrc。

1. 先安装依赖

```sh
npm i @babel/core babel-loader -D

npm i @babel/preset-env -D
```

2. 添加 babel 的配置文件 .babelrc

babel 有两个比较重要的概念，即 presets 和 plugins，可以理解为一个 plugin 对应一个功能，一个 presets 对应一系列 plugins 的集合。

```json
{
  "presets": [
    "@babel/preset-env" // es6 相关的 env
  ],
  "plugins": [
    // "@babel/proposal-class-properties"
  ]
}
```

3. 修改 webpack 的配置文件

```js
const path = require('path')
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.js$/,
        use: 'babel-loader',
      },
    ],
  },
}
```

## React JSX

1. 安装 React 相关的依赖

```sh
npm i @babel/preset-react -D
```

2. 增加 React 的 babel presets 配置，

```json
{
  "presets": [
    "@babel/preset-env", // es6 相关的 env
    "@babel/preset-react"
  ],
  "plugins": [
    // "@babel/proposal-class-properties"
  ]
}
```

3. 修改 webpack 的配置文件，增加对 JSX 文件的解析

```js
const path = require('path')
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        use: 'babel-loader',
      },
    ],
  },
}
```

## TypeScript

如果你用到了 typescript，那么在项目中后缀为 .ts 或 .tsx 的文件需要使用 ts-loader 处理。

1. 安装依赖

不仅需要安装 typescript 和 ts-loader，还需要安装 react 和 react-dom 的类型文件。

```sh
npm i typescript ts-loader -D
npm i @types/react @types/react-dom -D
```

2. 添加 ts 的配置文件 tsconfig.json

```json
{
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "noImplicitAny": true,
    "module": "es6",
    "target": "es5",
    "jsx": "react", // 解决`无法使用 JSX，除非提供了 "--jsx" 标志问题`问题
    "allowJs": true
  },
  "include": ["src"]
}
```

3. 更新 webpack 的配置文件

```js
const path = require('path')

module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.(ts|tsx)$/,
        use: 'ts-loader',
      },
    ],
  },
}
```

如果使用了 TypeScrit，还需要为图片、字体等资源模块添加描述文件。

```typescript
// index.d.ts

declare module '*.svg'
declare module '*.png'
declare module '*.jpg'
declare module '*.jpeg'
declare module '*.gif'
declare module '*.bmp'
declare module '*.tiff'
```

## CSS （less/sass/stylus）

解析 CSS 文件需要使用 css-loader，它会加载 .css 文件，并转换成 commonjs 对象，插入到 JS 中。
使用 style-loader 将样式通过 `<style>` 标签插入到 head 中。

其中，要注意 loader 是链式调用的，执行顺序是从右到左。

```js
const path = require('path')
module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          // loader 是链式调用的，执行顺序是从右到左 （从下到上）
          'style-loader',
          'css-loader',
        ],
      },
    ],
  },
}
```

实际开发中，我们会用到 less 或 sass 等 CSS 预处理器，其解析同样需要用到对应的 loader。按照 loader 的执行顺序，其 loader 应该放在 css-loader 之后，

- less-loader
- sass-loader
- stylus- loader

例如，less-loader 用于将 less 文件转换成 css

1. 安装依赖

```sh
npm i css-loader style-loader -D
npm i less less-loader -D
```

2. 更新 webpack 配置文件

```js
const path = require('path')

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  module: {
    rules: [
      {
        test: /\.less$/,
        use: [
          'style-loader', // 将 JS 字符串生成为 style 节点
          'css-loader', // 将 CSS 转化成 CommonJS 模块
          'less-loader', // 将 less 编译成 CSS
        ],
      },
    ],
  },
}
```

## 图片与字体等资源文件

> webpack 5 对图片、字体等资源的解析方式发生了变化，可以查看 [Asset Modules](https://webpack.js.org/guides/asset-modules/).
>
> 如果是使用 webpack 4，则可以参考下面的解析方式，虽然现在 webpack 5 中也支持该解析方式，不过在将来会下线掉这种方式。具体的说明可以查看 [To v5 from v4](https://webpack.js.org/migrate/5/)
>
> "If you have rules defined for loading assets using raw-loader, url-loader, or file-loader, please use [Asset Modules](https://webpack.js.org/guides/asset-modules/) instead as they're going to be deprecated in near future."

处理资源文件主要用到下面这 3 个 loaders，

- raw-loader 导入资源的源代码，如将 txt 文件导入为字符串
- file-loader 将文件输出为一个单独的文件，并导出可访问的 URL
- url-loader 将文件作为 data URI 内联到 bundle 中

通过 file-loader 可以处理文件，只需要匹配图片资源的后缀即可。

```js
const path = require('path')

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  module: {
    rules: [
      {
        test: /\.(png|svg|jpg|gif)$/,
        use: ['file-loader'],
      },
    ],
  },
}
```

file-loader 也可以处理字体，

```js
module: {
  rules: [
    {
      test: /\.(woff|woff2|eot|ttf|otf)$/,
      use: ['file-loader'],
    },
  ]
}
```

另外，使用 url-loader 也可以处理图片和字体文件，并且可以设置较小的资源自动 base64 转换。

url-loader 内部也是基于 file-loader 的。

```js
module: {
  rules: [
    {
      test: /\.(png|svg|jpg|gif)$/,
      use: [
        {
          loader: 'url-loader',
          options: {
            limit: 10240, // 10k，单位：字节
          },
        },
      ],
    },
  ]
}
```
